#!/usr/bin/env python

"""Transforms the charset table available at
ttp://www.loc.gov/marc/specifications/codetables.xml into python code."""

from xml.sax import parse
from xml.sax.handler import ContentHandler

class Charset:
    def __init__ (self, name, code):
        self.charset_name = name
        self.charset_code = code
        self.by_marc = {}
    def set_char (self, char_marc, char_ucs, char_name, combining):
        self.by_marc [int (char_marc, 16)] = \
                     (int (char_ucs, 16), char_name.replace ('\n', ' '),
                      combining [0].upper () == 'T')
    def write (self, f):
        l = []
        for k, v in self.by_marc.iteritems ():
            s = '\t0x%x: (0x%x, %d),# %s' % (k, v[0], v[2], v[1])
            l.append (s)
        l [-1] = l[-1].replace (',#', '#')
        # yuck, but last elt. can't have comma
        f.write ("\n".join (l))
        

class MyContentHandler (ContentHandler):
    def startDocument (self):
        self.charsets = {}
        self.code_to_charset = {}
        self.accum = None
        print "starting document"

    def display (self):
        """For debugging purposes."""
        for k,v in self.charsets.iteritems ():
            print k, self.code_to_charset [k], len (v.by_marc)
        print self.charsets['67'].by_marc
        print self.charsets ['45'].by_marc


    def endDocument (self):
        pyf = file ('marc_to_unicode.py', 'w')
        pyf.write ('# auto-generated by parse_marc_codetable.py\n')
        for k,v in self.charsets.iteritems ():
            pyf.write ('charset_%s = { # %s\n' % (k, self.code_to_charset[k]))
            v.write (pyf)
            pyf.write ('\n}\n')

        pyf.write ('codesets = {\n')
        l = []
        for k in self.charsets.iterkeys ():
            l.append ('\t0x%s: charset_%s' % (k, k))
        pyf.write (",\n".join (l))
        pyf.write ("}\n")
        pyf.close ()
        


    def startElement (self, name, attrs):
#        print "elt", name, attrs.keys ()
        if name == 'characterSet':
            self.cur_charset = attrs ['ISOcode']
            self.charsets [self.cur_charset] = Charset (attrs['name'],
                                                        attrs['ISOcode'])
            self.code_to_charset [attrs['ISOcode']] = attrs['name']
        elif name == 'code':
            self.cur_dest = None
            self.cur_dict = {}
            self.cur_dict ['isCombining'] = 'false'
        elif (name == 'marc' or name == 'ucs' or
              name == 'name' or name == 'isCombining' or
              name == 'alt'):
            self.cur_dest = name
            self.accum = ''
        elif name in ['codeTables', 'codeTable', 'note', 'utf-8',
                      'altutf-8', 'p', 'grouping', 'P']:
            self.cur_dest = None
        else:
            print "unhandled elt", name, attrs.keys ()
            self.cur_dest = None
        
        

    def endElement (self, name):
        if name == 'code':
            ch = self.cur_dict ['ucs']
            intch = int (ch, 16)
            
            # LC 's .xml file preserves variant forms by using the Unicode
            # space from 0xE900, in the middle of the private use area.
            # It might be possible to define a mapping from those
            # private use characters to the F900-fa5f compatibility
            # characters, but there's no algorithmic method I see,
            # so I'll wait for a new revision of the mapping tables
            # and in the meantime use the "alt" character whenever
            # the "ucs" character is in the private use area.

            # XXX: hangul from e8b0 - e8f2 are all mapped to same alt Unicode
            # 0x3013, which is "GETA MARK" - "substitute for ideograph not
            # in font".  Perhaps this should be replaced with an appropriate
            # sequence of Unicode combining characters?  I should find
            # a copy of EACC / ANSI Z39.64 to see what these characters
            # actually are
            

            # surrogates from d800-dfff
            # E800 - F8FF are private use area
            # F900 - fa5f are CJK compatibility ideographs,
            # and above are various presentation forms, etc. 
            
            if intch >= 0xe000 and intch < 0xF900:
                newch = self.cur_dict.get ('alt', ch)
                print "substituting for ch", ch, newch
                ch = newch
                
            self.charsets [self.cur_charset].set_char (
                self.cur_dict['marc'], ch,
                self.cur_dict['name'], self.cur_dict ['isCombining'])
        elif self.cur_dest <> None:
            self.cur_dict [name] = self.accum
            self.accum = None
            

    def characters (self, content):
        if self.accum <> None:
            self.accum = self.accum + content

    
def read_table ():
    f = file ("codetables.xml")
    parse (f, MyContentHandler ())

if __name__ == "__main__":
    read_table ()
